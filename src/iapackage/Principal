package iapackage;

import moteurs.*;
import java.util.Arrays;

import capteurs.*;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.motor.Motor;
import lejos.robotics.RegulatedMotor;
import lejos.robotics.chassis.Chassis;
import lejos.robotics.chassis.Wheel;
import lejos.robotics.chassis.WheeledChassis;
import lejos.robotics.navigation.MovePilot;
import lejos.utility.Delay;
import lejos.hardware.port.MotorPort;
import lejos.hardware.port.Port;
import lejos.hardware.port.SensorPort;
import lejos.hardware.BrickFinder;
import lejos.hardware.lcd.GraphicsLCD;
import lejos.hardware.motor.BaseRegulatedMotor;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.motor.Motor;
import lejos.hardware.port.MotorPort;
import lejos.hardware.port.TachoMotorPort;
import lejos.robotics.Color;
import lejos.robotics.RegulatedMotor;
import lejos.robotics.chassis.Wheel;
import lejos.utility.Delay;
import lejos.robotics.navigation.MovePilot;
import lejos.robotics.navigation.MovePilot.*;
import lejos.robotics.SampleProvider;


public class Principal {
	private static Action a;
	private static ToucherCapteur touch;
	private static Pince pince;
	private static DistanceCapteur distance;
	
	public Principal(Action action, Pince pince, ToucherCapteur t, DistanceCapteur d) {
		a=action;
		this.pince=pince;
		touch=t;
		distance=d;
	}
	
	public void avancerPlusPrendrePalet() {//avance jusqu'a ce qu'un palet soit touché, puis ferme les pinces
		pince.ouvrir();
		a.setVitesse(200);
		a.avancer();
		while(!touch.estTouche()) { //s'arrête que quand le capteur touche le palet
		}
		a.stop();
		pince.fermer();
		a.tournerG(180);
		a.avancer(200);
	}

public void recalibrage() {//S'orienter vers les cages adverses, reclaibrage basique sans accident
				int ang= angle%360;
				a.tournerG(ang);
			}
			
	
	public void recherche() {
		distance.ouvrir();
		Delay.msDelay(200);
		float[] sample = new float[0];
		int i = 0;
		a.asyncTournerG((double)360);
		while(a.isMoving()) {
			sample=distance.recherche(sample);
			i++;
		}
		System.out.println(sample.length);
		
		float[] min = min(sample);
		
		//System.out.println(Arrays.toString(sample));
		//System.out.println(Arrays.toString(min));
		

		System.out.println(min[0]);

		double angleMin = 360.0 *((min[2]+min[3])/2)*1.4 / i; //le *1.4 est un coefficient estimé qui corrige l'angle 
		System.out.println(angleMin);

		a.tournerG(angleMin);
		/*pince.ouvrir();
		a.avancer(100);
		while(!(touch.estTouche())){
		}
		a.stop();
		pince.fermer();
		a.tournerD(180);
		a.avancer(300, 100);*/
	//TODO impémenter l'angle pour la "boussole"
	}
	
	public static float[] min(float[] tab) {
		float min = tab[0];
		int indexMin = 0;
		int index1 = 0, index2 = 0;
		for(int i=1;i<tab.length;i++) {
			if(tab[i]!=0 && tab[i]+0.05<min){
				index1 = i;
			}
			if(tab[i]!=0 && tab[i]<min) {
				min=tab[i];
				indexMin=i;
			}if( (tab[i]!=0) && (tab[i-1]-0.05<min) && (tab[i]-0.05>min) ){
				index2 = i;
			}
			
		}
		float[] t = new float[] {min, indexMin, index1, index2};
		System.out.println("Minimum :" + Arrays.toString(t));
		System.out.println(tab.length);
		//System.out.println("début : " + tab[index1] + " , fin : " + tab[index2] );
		return t;
	}
	
	public static void main(String[] args) {
		Principal p = new Principal(new Action(MotorPort.D,MotorPort.C),new Pince(MotorPort.A),new ToucherCapteur(SensorPort.S3),new DistanceCapteur());
		p.recherche();
	}
}
