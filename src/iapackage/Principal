package iapackage;

import moteurs.*;
import java.util.Arrays;

import capteurs.*;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.motor.Motor;
import lejos.robotics.RegulatedMotor;
import lejos.robotics.chassis.Chassis;
import lejos.robotics.chassis.Wheel;
import lejos.robotics.chassis.WheeledChassis;
import lejos.robotics.navigation.MovePilot;
import lejos.utility.Delay;
import lejos.hardware.port.MotorPort;
import lejos.hardware.port.Port;
import lejos.hardware.port.SensorPort;
import lejos.hardware.BrickFinder;
import lejos.hardware.lcd.GraphicsLCD;
import lejos.hardware.motor.BaseRegulatedMotor;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.motor.Motor;
import lejos.hardware.port.MotorPort;
import lejos.hardware.port.TachoMotorPort;
import lejos.robotics.Color;
import lejos.robotics.RegulatedMotor;
import lejos.robotics.chassis.Wheel;
import lejos.utility.Delay;
import lejos.robotics.navigation.MovePilot;
import lejos.robotics.navigation.MovePilot.*;
import lejos.robotics.SampleProvider;


public class Principal {
	private static Action a;
	private static ToucherCapteur touch;
	private static Pince pince;
	private static DistanceCapteur distance;
	private static CouleurCapteur color;
	private int position; // = 1 si à gauche, 2 si au milieu, 3 si a droite
	private int angle; //représente l'angle vers lequel le robot est tourné

	public Principal(Action action, Pince pince, ToucherCapteur t, DistanceCapteur d,CouleurCapteur c) {
		this.a=action;
		this.pince=pince;
		this.touch=t;
		this.distance=d;
		this.color=c;
		this.angle=0;
	}

	public void setPosition(int p) {
		position=p;
	}

	public int getPosition() {
		return position;
	}

	public void recalibrage() {
		int ang= angle%360;
		this.angle=0;
		a.tournerG(ang);
	}

	public void eviterRobot() {
		if (pince.estFermée()&&touch.estTouche()&&distance.getDistance()<270) {
			float distanceProvisoire=distance.getDistance();
			Delay.msDelay(100);
			if(distance.getDistance()<distanceProvisoire-5)
				a.tournerD(100);
			a.avancer(150,100);
			a.tournerG(100);
		}
	}

	public void avancerPlusPrendrePalet(int vitesse) {
		if (pince.estFermée())
			pince.ouvrir();
		a.setVitesse(vitesse);
		a.avancer();
		while(!touch.estTouche()) { //s'arrête que quand le capteur touche le palet
		}
		a.stop();
		pince.fermer();
	}

	public void recherche() {
		float[] tab = new float[0];
		int j=0;
		int t=0;
		boolean b = true;
		float min = (float)0.75;
		a.asyncTournerG((double)360);
		while(a.isMoving()) {
			tab=distance.recherche(tab);
			if(tab[tab.length-1]!=0 && tab[tab.length-1]+0.05<min){
				j=tab.length-1;
				System.out.println("index debut = " + j + " , valeur = " +tab[j]);
			}
			if(tab[tab.length-1]!=0 && tab[tab.length-1]<min) {
				min=tab[tab.length-1];
			}if((tab.length>1) && (j!=0) && (tab[tab.length-1]!=0) && (tab[tab.length-2]-0.1<min) && (tab[tab.length-1]-0.1>min) ){
				t=tab.length-1;
				System.out.println("index fin = " + t + " , valeur = " +tab[t]);
				System.out.println(t-j);
				if (min>0.15 && min<0.35 && (t-j)<300 && (t-j)>10) {
					a.stop();
					a.tournerD(40);
					b=false;
				}else if (min>0.35 && min<0.45 && (t-j)<200 && (t-j)>10) {
					a.stop();
					a.tournerD(40);
					b=false;
				}else if (min>0.45 && min<0.55 && (t-j)<100 && (t-j)>10) {
					a.stop();
					a.tournerD(40);
					b=false;
				}else if (min>0.55 && min<0.75 && (t-j)<80 && (t-j)>10) {
					a.stop();
					a.tournerD(40);
					b=false;
				}
				min=(float)0.55;
				j=0;
				t=0;
			}
		}System.out.println(tab.length);	
		//if(b) {
			//this.recherche();
		//}
		System.out.println(Arrays.toString(tab));
	}

	public void ramenerPalet () {
		recalibrage();
		while (color.nomCouleur(color.getCouleur())!="BLANC") {
			eviterRobot();
			a.avancerAsync(100);
		}
		pince.ouvrir();
	}

	public void prendrePremierPalet() {
		a.setVitesse(350);
		avancerPlusPrendrePalet(180);
		a.tournerD(45);
		a.avancer(450);
		a.tournerG(45);
		a.avancer();
		while(color.nomCouleur(color.getCouleur())!="BLANC") {
			eviterRobot();
		}
		a.tournerG(45);
		a.avancerAsync(500);
		a.tournerD(45);
		a.stop();
	}


	public void ramenerDeuxPalets() {
		a.tournerD(180);
		avancerPlusPrendrePalet(180);
		a.tournerD(180);
		a.avancer(600,3000);
		pince.ouvrir();
		avancerPlusPrendrePalet(180);
		a.tournerD(180);
		a.avancer(1200,3000);
		pince.ouvrir();
		a.tournerD(180);

	}

	public void RejoindreMilieuApresDébut(){
		if (position == 1) {
			a.tournerD(90);
			a.avancer(250);
			a.tournerG(90);
			a.avancer(900);
		}
		if (position == 2) {
			a.avancer(900);
		}
		else {
			a.tournerG(90);
			a.avancer(250);
			a.tournerD(90);
			a.avancer(900);
		}
	}

	public void test3palets1(){
		
		avancerPlusPrendrePalet(300);
		seDecalerD();
		avancerJusqueCouleur("blanc");
		pince.ouvrir();
		a.reculer(100, 300);
		pince.fermer();
		a.tournerG(90);
		avancerJusqueCouleur("jaune");
		a.avancer(100, 200);
		a.tournerG(90);
		avancerPlusPrendrePalet(300);
		a.tournerG(180);
		avancerJusqueCouleur("blanc");
		pince.ouvrir();
		a.reculer(100, 300);
		pince.fermer();
		a.tournerG(180);
		avancerPlusPrendrePalet(300);
		a.tournerG(180);
		avancerJusqueCouleur("blanc");
		pince.ouvrir();
		a.reculer(100, 300);
		pince.fermer();	
	}

	public static void main(String[] args) {
		Principal p = new Principal(new Action(MotorPort.D,MotorPort.C),new Pince(MotorPort.A),new ToucherCapteur(SensorPort.S3),new DistanceCapteur(SensorPort.S4), new CouleurCapteur(SensorPort.S1));
		int strategie = 0;
		int dMid = 500; //TODO distance pour aller de la ligne blanche au milieu
		int dCase = 300; //TODO distance pour avancer de pile une case
		switch (strategie) {
		case 0: //---------------------------------------en face à gauche---------------------------------------
			a.tournerD(90);
			a.avancer(dCase);
			a.tournerG(90);
			p.test1();
			a.tournerG(180);
			a.avancer(dMid);
			for(int i = 0; i<100; i++) {
				p.recherche();
				p.retourLigneBlanche();
				p.retournerMilieu();
			}
		case 1: //---------------------------------------en face à droite---------------------------------------
			a.tournerG(90);
			a.avancer(dCase);
			a.tournerD(90);
			p.test1();
			a.tournerG(180);
			a.avancer(dMid);
			for(int i = 0; i<100; i++) {
				p.recherche();
				p.retourLigneBlanche();
				p.retournerMilieu();
			}
		case 2: //---------------------------------------en face au milieu---------------------------------------
			a.tournerG(90);
			a.avancer(dCase);
			a.tournerD(90);
			p.test1();
			a.tournerG(180);
			a.avancer(dMid);
			for(int i = 0; i<100; i++) {
				p.recherche();
				p.retourLigneBlanche();
				p.retournerMilieu();
			}
		case 3: //---------------------------------vol s'ils se mettent à gauche---------------------------------
			//se mettre au milieu
			p.prendrePremierPalet();
			a.tournerG(90);
			a.avancer(dCase);
			a.tournerG(90);
			p.avancerPlusPrendrePalet();//on prend leur palet du milieu
			a.tournerG(180);
			while(ligneBlanche) {
			}
			a.stop();
			pince.ouvrir();
			a.avancerAsync(-100); //TODO voir de combien reculer
			pince.fermer();
			a.tournerD(90);
			a.avancer(dCase);
			a.tournerD(90);
			a.avancer(dMid);
			for(int i = 0; i<100; i++) {
				p.recherche();
				p.retourLigneBlanche();
				p.retournerMilieu();
			}
		case 4: //---------------------------------vol s'ils se mettent à droite---------------------------------
			//se mettre au milieu
			p.prendrePremierPalet();//TODO il faudrait partir à gauche avant de prendre le premier palet
			a.tournerD(90);
			a.avancer(dCase);
			a.tournerD(90);
			p.avancerPlusPrendrePalet();//on prend leur palet du milieu
			a.tournerG(180);
			while(ligneBlanche) {
			}
			a.stop();
			pince.ouvrir();
			a.avancerAsync(-100); //TODO voir de combien reculer
			pince.fermer();
			a.tournerG(90);
			a.avancer(dCase);
			a.tournerG(90);
			a.avancer(dMid);
			for(int i = 0; i<100; i++) {
				p.recherche();
				p.retourLigneBlanche();
				p.retournerMilieu();
			}
		}
	}
}
